name: Release Management

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., 1.2.3)'
        required: false
        type: string
      release_type:
        description: 'Type of release'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
          - prerelease
      dry_run:
        description: 'Dry run (no actual release)'
        required: false
        default: false
        type: boolean

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

env:
  PYTHON_VERSION: '3.11'
  NODE_VERSION: '18'

jobs:
  # Version Calculation
  calculate-version:
    name: Calculate Next Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      changelog: ${{ steps.version.outputs.changelog }}
      should_release: ${{ steps.version.outputs.should_release }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: Install semantic-release
      run: npm install
      
    - name: Calculate version
      id: version
      run: |
        if [[ "${{ github.event.inputs.dry_run }}" == "true" ]]; then
          echo "Running in dry-run mode"
          npx semantic-release --dry-run
          echo "should_release=false" >> $GITHUB_OUTPUT
        else
          # Run semantic-release to calculate next version
          if [[ -n "${{ github.event.inputs.version }}" ]]; then
            echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
            echo "should_release=true" >> $GITHUB_OUTPUT
          else
            # Let semantic-release determine version
            echo "should_release=true" >> $GITHUB_OUTPUT
          fi
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Pre-release Checks
  pre-release-checks:
    name: Pre-release Quality Checks
    runs-on: ubuntu-latest
    needs: calculate-version
    if: needs.calculate-version.outputs.should_release == 'true'
    timeout-minutes: 30
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pytest pytest-cov bandit safety
        
    - name: Run tests
      run: |
        pytest tests/ --cov=lexgraph_legal_rag --cov-fail-under=80
        
    - name: Security check
      run: |
        bandit -r src/ -f json -o bandit-report.json
        safety check
        
    - name: Build check
      run: |
        python -m pip install build
        python -m build
        
    - name: Validate version bump
      run: |
        echo "Pre-release checks passed for version: ${{ needs.calculate-version.outputs.version }}"

  # Create Release
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [calculate-version, pre-release-checks]
    if: needs.calculate-version.outputs.should_release == 'true'
    environment: production
    timeout-minutes: 20
    outputs:
      release_created: ${{ steps.release.outputs.release_created }}
      tag_name: ${{ steps.release.outputs.tag_name }}
      version: ${{ steps.release.outputs.version }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        
    - name: Install dependencies
      run: npm install
      
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Update version files
      if: github.event.inputs.version != ''
      run: |
        # Update pyproject.toml version
        sed -i 's/version = "[^"]*"/version = "${{ github.event.inputs.version }}"/' pyproject.toml
        
        # Update package.json version
        sed -i 's/"version": "[^"]*"/"version": "${{ github.event.inputs.version }}"/' package.json
        
    - name: Create release with semantic-release
      id: release
      run: |
        npx semantic-release
        echo "release_created=true" >> $GITHUB_OUTPUT
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Upload release assets
      if: steps.release.outputs.release_created == 'true'
      run: |
        echo "Release created successfully"

  # Build and Publish Package
  publish-package:
    name: Publish Python Package
    runs-on: ubuntu-latest
    needs: create-release
    if: needs.create-release.outputs.release_created == 'true'
    environment: production
    timeout-minutes: 15
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install build dependencies
      run: |
        python -m pip install --upgrade pip
        pip install build twine
        
    - name: Build package
      run: |
        python -m build
        
    - name: Check package
      run: |
        twine check dist/*
        
    - name: Publish to PyPI
      env:
        TWINE_USERNAME: __token__
        TWINE_PASSWORD: ${{ secrets.PYPI_API_TOKEN }}
      run: |
        twine upload dist/*
        
    - name: Verify package upload
      run: |
        echo "Package published successfully to PyPI"
        echo "Version: ${{ needs.create-release.outputs.version }}"

  # Build and Push Docker Images
  publish-docker:
    name: Publish Docker Images
    runs-on: ubuntu-latest
    needs: create-release
    if: needs.create-release.outputs.release_created == 'true'
    environment: production
    timeout-minutes: 30
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: |
          ghcr.io/${{ github.repository }}
          terraglonlabs/lexgraph-legal-rag
        tags: |
          type=ref,event=tag
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=semver,pattern={{major}}
          type=raw,value=latest
          
    - name: Build and push Docker images
      uses: docker/build-push-action@v5
      with:
        context: .
        target: production
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        build-args: |
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
          VCS_REF=${{ github.sha }}
          VERSION=${{ needs.create-release.outputs.version }}
          
    - name: Verify Docker images
      run: |
        echo "Docker images published successfully:"
        echo "${{ steps.meta.outputs.tags }}"

  # Update Documentation
  update-docs:
    name: Update Documentation
    runs-on: ubuntu-latest
    needs: create-release
    if: needs.create-release.outputs.release_created == 'true'
    timeout-minutes: 15
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Update version in documentation
      run: |
        # Update version references in documentation
        find docs/ -name "*.md" -exec sed -i 's/Version: [0-9]\+\.[0-9]\+\.[0-9]\+/Version: ${{ needs.create-release.outputs.version }}/g' {} +
        
        # Update API documentation version
        if [ -f "docs/api/openapi.yaml" ]; then
          sed -i 's/version: "[^"]*"/version: "${{ needs.create-release.outputs.version }}"/' docs/api/openapi.yaml
        fi
        
    - name: Generate changelog
      run: |
        echo "# Changelog" > CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "## Version ${{ needs.create-release.outputs.version }}" >> CHANGELOG.md
        echo "" >> CHANGELOG.md
        echo "Released: $(date '+%Y-%m-%d')" >> CHANGELOG.md
        echo "" >> CHANGELOG.md
        git log --oneline --pretty=format:"- %s" $(git describe --tags --abbrev=0)..HEAD >> CHANGELOG.md || echo "- Initial release" >> CHANGELOG.md
        
    - name: Commit documentation updates
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add .
        git diff --staged --quiet || git commit -m "docs: update documentation for version ${{ needs.create-release.outputs.version }}"
        git push

  # Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [create-release, publish-docker]
    if: needs.create-release.outputs.release_created == 'true'
    environment:
      name: production
      url: https://lexgraph.terragon.ai
    timeout-minutes: 30
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Deploy to production
      run: |
        echo "Deploying version ${{ needs.create-release.outputs.version }} to production"
        # Add your production deployment commands here
        # Example: kubectl set image deployment/lexgraph lexgraph=ghcr.io/${{ github.repository }}:${{ needs.create-release.outputs.version }}
        
    - name: Run deployment verification
      run: |
        echo "Verifying production deployment"
        # Add deployment verification commands
        # Example: kubectl rollout status deployment/lexgraph
        
    - name: Run smoke tests
      run: |
        echo "Running production smoke tests"
        # Add smoke test commands
        # Example: curl -f https://lexgraph.terragon.ai/health

  # Notification and Cleanup
  post-release:
    name: Post-release Tasks
    runs-on: ubuntu-latest
    needs: [create-release, publish-package, publish-docker, update-docs, deploy-production]
    if: always() && needs.create-release.outputs.release_created == 'true'
    timeout-minutes: 10
    
    steps:
    - name: Create release summary
      run: |
        echo "## 🚀 Release Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Version**: ${{ needs.create-release.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "**Tag**: ${{ needs.create-release.outputs.tag_name }}" >> $GITHUB_STEP_SUMMARY
        echo "**Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "**Released**: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ✅ Deployment Status" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| PyPI Package | ${{ needs.publish-package.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Docker Images | ${{ needs.publish-docker.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Documentation | ${{ needs.update-docs.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Production Deploy | ${{ needs.deploy-production.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 🔗 Release Links" >> $GITHUB_STEP_SUMMARY
        echo "- [GitHub Release](https://github.com/${{ github.repository }}/releases/tag/${{ needs.create-release.outputs.tag_name }})" >> $GITHUB_STEP_SUMMARY
        echo "- [PyPI Package](https://pypi.org/project/lexgraph-legal-rag/${{ needs.create-release.outputs.version }}/)" >> $GITHUB_STEP_SUMMARY
        echo "- [Docker Images](https://ghcr.io/${{ github.repository }}:${{ needs.create-release.outputs.version }})" >> $GITHUB_STEP_SUMMARY
        echo "- [Production Deployment](https://lexgraph.terragon.ai)" >> $GITHUB_STEP_SUMMARY
        
    - name: Notify team
      uses: 8398a7/action-slack@v3
      if: always()
      with:
        status: ${{ job.status }}
        channel: '#releases'
        webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        text: |
          🚀 LexGraph Legal RAG ${{ needs.create-release.outputs.version }} has been released!
          
          Status: ${{ job.status }}
          Commit: ${{ github.sha }}
          
          Release: https://github.com/${{ github.repository }}/releases/tag/${{ needs.create-release.outputs.tag_name }}
          Production: https://lexgraph.terragon.ai
          
    - name: Create follow-up issues
      if: failure()
      run: |
        echo "Creating follow-up issues for failed release steps"
        # Add issue creation logic for failed steps
        
    - name: Clean up
      run: |
        echo "Release workflow completed"
        echo "Version ${{ needs.create-release.outputs.version }} is now live in production"